<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8">
  <title>AR GIF Sample</title>
  <script src="https://aframe.io/releases/1.7.1/aframe.min.js"></script>
  <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
  <script src="https://unpkg.com/gifuct-js/dist/gifuct.min.js"></script>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>

<body>
  <a-scene embedded arjs="patternRatio:0.9">
    <a-assets>
      <img id="gif1" src="./assets/pattern-marker.png" crossorigin="anonymous">
    </a-assets>

    <a-marker type="pattern" url="./assets/pattern-marker.patt">
      <a-plane id="gifPlane" position="0 0.5 0" rotation="-90 0 0" width="2" height="2"></a-plane>
    </a-marker>

    <a-entity camera></a-entity>
  </a-scene>

  <script>
    const gifImg = document.getElementById('gif1');

    gifImg.onload = async () => {
      // GIFをArrayBufferとして取得
      const response = await fetch(gifImg.src);
      const arrayBuffer = await response.arrayBuffer();

      // gifuct-jsでフレーム分解
      const parsedGif = window.gifuct.parseGIF(arrayBuffer);
      const frames = window.gifuct.decompressFrames(parsedGif, true);

      // Canvas作成
      const canvas = document.createElement('canvas');
      canvas.width = frames[0].dims.width;
      canvas.height = frames[0].dims.height;
      const ctx = canvas.getContext('2d');

      // A-Frame plane に canvas を貼る
      const plane = document.querySelector('#gifPlane');
      plane.setAttribute('material', 'src', canvas);

      // フレームアニメーション
      let currentFrame = 0;

      function animateFrame() {
        const frame = frames[currentFrame];

        // 前フレームをクリア（透明部分もリセット）
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // ImageDataを作成して描画
        const imageData = ctx.createImageData(frame.dims.width, frame.dims.height);
        imageData.data.set(frame.patch);
        ctx.putImageData(imageData, frame.dims.left, frame.dims.top);

        // A-Frameに更新通知
        plane.getObject3D('mesh').material.map.needsUpdate = true;

        // 次フレーム
        currentFrame = (currentFrame + 1) % frames.length;

        // 遅延時間（frame.delayは1/100秒単位）
        setTimeout(animateFrame, frame.delay * 10 || 100);
      }

      animateFrame();
    };
  </script>
</body>
</html>
